---
layout: post
read_time: true
show_date: true
title: "Daily record"
date: 2021-04-02
img: posts/20210402/post7-header.webp
tags: [coding, daily, bug fix]
category: theory
author: TM
description: "日常总结记录"
---
## Daily
## 2022-04-18 单机锁 & 分布式锁 [参考](https://time.geekbang.org/column/intro/100056701)
* 单机锁
    - 我们常说的单机锁实际上就是在一个进程内的多个线程操作的一个变量，该变量对于该进程内的所有线程都是可见的，类似于java中的volatile关键字的作用。

    对于在单机上运行的多线程程序来说，锁本身可以用一个变量表示。

    - 变量值为0时，表示没有线程获取锁;

    - 变量值为1时，表示已经有线程获取到锁了。
* 分布式锁

    和单机上的锁类似，分布式锁同样可以用一个变量来实现。客戶端加锁和释放锁的操作逻辑，也和单机上的 加锁和释放锁操作逻辑一致:加锁时同样需要判断锁变量的值，根据锁变量值来判断能否加锁成功;释放锁 时需要把锁变量值设置为0，表明客戶端不再持有锁。

    和线程在单机上操作锁不同的是，在分布式场景下，锁变量需要由一个共享存储系统来维护，只有这样，多个客戶端才可以通过访问共享存储系统来访问锁变量。相应的，加锁和释放锁的操作就变成了读取、 判断和设置共享存储系统中的锁变量值。

    因此为了能够实现分布式锁，则需要多个不同的进程能够访问同一个共享的变量，因此常见的方式则为基于共享的数据库或者缓存实现分布式锁。在目前开发中，常见的分布式锁的实现方式则是通过*Redis*以及*Zookeeper*实现分布式锁。今天主要是了解复习了基于*Redis*的分布式锁的实现方式。

* 基于Redis的分布式锁实现方式

    - 单机Redis

        基于单机的Redis实现分布式锁比较简单，通过key-value形式保存每个客户端的锁，但是在设置锁的时候存在三个步骤->读取锁变量值、判断锁变量值，设置锁变量值。因此，这三个步骤的原子性则决定了加锁的安全性。为了能够保证该三个操作的原子性，我们再*Redis*中常用的主要分为两种模式：
        - 原生命令
        - lua脚本

        对于原生命令，我们则可以通过*SETNX*和*SET*操作来保证，对于LUA脚本，可以详细去学习如何在*Redis*中运行LUA脚本。
    ``` go
    // 加锁
    SETNX lock1 1
    // 业务代码
    TODO
    // 释放锁
    DEL lock1
    ```
    但是该方式存在着一定的问题：

    1. 一直没有执行最后的DEL命令释放锁。因此，锁就一直被这个客戶端持有，其它客戶端无法拿到锁。
    ```python
    SET KEY VALUE [EX seconds | ]
    ```
    2. 假设客戶端B执行了DEL命令释放锁，此时，客戶端A的锁就被误释放了。如果客戶端C正好也在申请加锁，就可以成功获得锁，进而开始操作共享 数据。这样一来，客戶端A和C同时在对共享数据进行操作，数据就会被修改错误，这也是业务层不能接受的。

    为了解决上述两个问题，可以通过设置过期时间，以及为每个客户端生成一个唯一ID，在删除锁的时候进行判定。 
    ```lua
    //释放锁 比较unique_value是否相等，避免误释放
    if redis.call("get",KEYS[1]) == ARGV[1] then
        return redis.call("del",KEYS[1]) 
    else
        return 0 
    end
    ```   
    - 分布式Redis

        目前最常见的分布式Redis锁就是红锁(RedLock)，Redlock算法的基本思路，是让客戶端和多个独立的Redis实例依次请求加锁，如果客戶端能够和半数以上 的实例成功地完成加锁操作，那么我们就认为，客戶端成功地获得分布式锁了，否则加锁失败。主要步骤分为三步：
        1. 客户端获取当前时间戳
        2. 客户端按照顺序依次向N个客户端进行加锁操作
        3. 客户端计算整体的加锁时间

        客戶端只有在满足下面的这两个条件时，才能认为是加锁成功。
        - **条件一**:客戶端从超过半数(大于等于 N/2+1)的Redis实例上成功获取到了锁;
        - **条件二**:客戶端获取锁的总耗时没有超过锁的有效时间。

# 多阶hash 

